# app/core/types.py
"""
Shared type definitions used across the application.
"""
from dataclasses import dataclass, field
from typing import Any, Dict, List, Literal, Optional, TypedDict
from enum import Enum


# TypedDict for chat messages
class ChatMessage(TypedDict):
    role: str
    content: str





# File output from agents (dataclass version)
@dataclass
class GeneratedFile:
    """A file generated by an agent."""
    path: str
    content: str
    
    def to_dict(self) -> Dict[str, str]:
        return {"path": self.path, "content": self.content}



# Agent output structure
@dataclass
class AgentOutput:
    """Output from an agent call."""
    files: List[GeneratedFile] = field(default_factory=list)
    thinking: str = ""
    raw: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "files": [f.to_dict() for f in self.files],
            "thinking": self.thinking,
        }





# Workflow step result
@dataclass
class StepResult:
    """Result of executing a workflow step."""
    nextstep: str
    turn: int
    pause: bool = False
    status: str = "ok"
    data: Dict[str, Any] = field(default_factory=dict)
    token_usage: Optional[Dict[str, int]] = None  # V3: {"input": int, "output": int}
    error: Optional[str] = None  # For transient infrastructure failures (e.g., Gemini 503)


# Quality metrics
@dataclass
class QualityMetrics:
    """Quality metrics for a project."""
    total_files: int = 0
    total_lines: int = 0
    avg_quality_score: float = 0.0
    approvals: int = 0
    rejections: int = 0


# Token usage for cost tracking
@dataclass
class TokenUsage:
    """Track token usage for cost estimation."""
    input_tokens: int = 0
    output_tokens: int = 0
    
    @property
    def total(self) -> int:
        return self.input_tokens + self.output_tokens
    
    @property
    def estimated_cost(self) -> float:
        """Estimate cost based on Gemini pricing."""
        input_cost = (self.input_tokens / 1000) * 0.00025
        output_cost = (self.output_tokens / 1000) * 0.0005
        return round(input_cost + output_cost, 6)


# Workflow state
class WorkflowStatus(Enum):
    """
    Workflow-level outcomes (aggregate property).
    
    Phase 1: Updated to support degradation reporting.
    """
    RUNNING = "running"
    PAUSED = "paused"
    SUCCESS = "success"                              # Clean success (all steps passed)
    SUCCESS_WITH_DEGRADATION = "success_with_degradation"  # NEW: Degraded but coherent
    FAILED = "failed"
    
    # Legacy alias for backward compatibility
    COMPLETED = "success"


@dataclass
class DegradationReport:
    """
    Report for workflows that complete with degradation.
    
    Phase 1: This is an AGGREGATE property, not step-level.
    Degradation means some steps were isolated (dead branches).
    """
    isolated_steps: List[str]                      # Steps that were quarantined
    quarantined_artifacts: Dict[str, List[str]]    # Artifacts that are untrusted
    alternative_evidence: Dict[str, Any]           # Evidence from static validation
    message: str                                   # Human-readable summary





# ============================================================
# TypedDict types (from legacy agents/types.py)
# ============================================================




class QAIssue(TypedDict):
    """Quality assurance issue from Derek/Luna."""
    file: str
    line: int
    area: str
    description: str
    severity: Literal['critical', 'major', 'minor']
    suggested_fix: str
    codeContext: Optional[str]
    testableImpact: Optional[str]


class FilePlan(TypedDict):
    """File plan for workflow."""
    path: str
    description: str


class TestReport(TypedDict):
    """Test report from QA agents."""
    summary: str
    passed: bool
    issueCount: Optional[int]
    severityBreakdown: Optional[Dict[str, int]]
    issues: List[QAIssue]
    recommendations: Optional[List[str]]


class ToolCall(TypedDict):
    """A tool call from Marcus."""
    name: str
    args: Dict[str, Any]


class MarcusPlan(TypedDict):
    """Marcus's planning output."""
    thought: str
    tool_call: Optional[ToolCall]
    speak_to_user: Optional[str]

