# app/workflow/engine_v2/fallback_router_agent.py
"""
Minimal Router Generator (Used When Derek Fails)

Generates a minimal but valid FastAPI CRUD router.
Used ONLY when main LLM agent repeatedly fails.
"""


class FallbackRouterAgent:
    """
    Generates a minimal but valid FastAPI CRUD router.
    Used ONLY when main LLM agent repeatedly fails.
    """
    
    TEMPLATE = '''# backend/app/routers/notes.py
"""
Notes CRUD Router - Fallback Template
Generated by FallbackRouterAgent when LLM failed.
"""
from fastapi import APIRouter, HTTPException, Query
from typing import List, Optional
from beanie import PydanticObjectId

from app.models import Note

router = APIRouter(prefix="/api/notes", tags=["notes"])


@router.post("/", response_model=Note, status_code=201)
async def create(note: Note):
    """Create a new note."""
    await note.create()
    return note


@router.get("/", response_model=List[Note])
async def get_all(
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
):
    """Get all notes with pagination."""
    return await Note.find_all().skip(skip).limit(limit).to_list()


@router.get("/{note_id}", response_model=Note)
async def get_one(note_id: PydanticObjectId):
    """Get a single note by ID."""
    note = await Note.get(note_id)
    if not note:
        raise HTTPException(status_code=404, detail="Note not found")
    return note


@router.put("/{note_id}", response_model=Note)
async def update(note_id: PydanticObjectId, data: dict):
    """Update an existing note."""
    note = await Note.get(note_id)
    if not note:
        raise HTTPException(status_code=404, detail="Note not found")
    await note.set(data)
    return note


@router.delete("/{note_id}")
async def delete(note_id: PydanticObjectId):
    """Delete a note."""
    note = await Note.get(note_id)
    if not note:
        raise HTTPException(status_code=404, detail="Note not found")
    await note.delete()
    return {"status": "deleted", "id": str(note_id)}
'''

    def __init__(self, entity: str = "note"):
        """
        Args:
            entity: The entity name (e.g., "note", "task", "user")
        """
        self.entity = entity

    def generate(self) -> str:
        """Generate the fallback router code."""
        return self.TEMPLATE.strip()

    def generate_for_entity(self, entity: str, model_name: str) -> str:
        """Generate a router for a specific entity."""
        entity_lower = entity.lower()
        entity_plural = entity_lower + "s" if not entity_lower.endswith("s") else entity_lower
        
        return f'''# backend/app/routers/{entity_plural}.py
"""
{model_name} CRUD Router - Fallback Template
"""
from fastapi import APIRouter, HTTPException, Query
from typing import List
from beanie import PydanticObjectId

from app.models import {model_name}

router = APIRouter(prefix="/api/{entity_plural}", tags=["{entity_plural}"])


@router.post("/", response_model={model_name}, status_code=201)
async def create({entity_lower}: {model_name}):
    """Create a new {entity_lower}."""
    await {entity_lower}.create()
    return {entity_lower}


@router.get("/", response_model=List[{model_name}])
async def get_all(
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
):
    """Get all {entity_plural} with pagination."""
    return await {model_name}.find_all().skip(skip).limit(limit).to_list()


@router.get("/{{{entity_lower}_id}}", response_model={model_name})
async def get_one({entity_lower}_id: PydanticObjectId):
    """Get a single {entity_lower} by ID."""
    {entity_lower} = await {model_name}.get({entity_lower}_id)
    if not {entity_lower}:
        raise HTTPException(status_code=404, detail="{model_name} not found")
    return {entity_lower}


@router.put("/{{{entity_lower}_id}}", response_model={model_name})
async def update({entity_lower}_id: PydanticObjectId, data: dict):
    """Update an existing {entity_lower}."""
    {entity_lower} = await {model_name}.get({entity_lower}_id)
    if not {entity_lower}:
        raise HTTPException(status_code=404, detail="{model_name} not found")
    await {entity_lower}.set(data)
    return {entity_lower}


@router.delete("/{{{entity_lower}_id}}")
async def delete({entity_lower}_id: PydanticObjectId):
    """Delete a {entity_lower}."""
    {entity_lower} = await {model_name}.get({entity_lower}_id)
    if not {entity_lower}:
        raise HTTPException(status_code=404, detail="{model_name} not found")
    await {entity_lower}.delete()
    return {{"status": "deleted", "id": str({entity_lower}_id)}}
'''.strip()
