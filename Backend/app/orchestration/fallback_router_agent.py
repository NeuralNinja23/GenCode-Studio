# app/orchestration/fallback_router_agent.py
"""
Minimal Router Generator (Used When Derek Fails)

Generates a minimal but valid FastAPI CRUD router.
Used ONLY when main LLM agent repeatedly fails.

IMPORTANT: This agent is ALWAYS DYNAMIC.
- Entity and model_name are REQUIRED parameters
- No hardcoded defaults like "Note" or "Item"
- Uses centralized entity_discovery for pluralization
"""
from app.utils.entity_discovery import get_entity_plural


class FallbackRouterAgent:
    """
    Generates a minimal but valid FastAPI CRUD router.
    Used ONLY when main LLM agent repeatedly fails.
    
    DYNAMIC: Always requires entity parameter - no hardcoded defaults.
    """
    
    # NOTE: Removed hardcoded TEMPLATE constant that used "notes/Note".
    # All generation now uses generate_for_entity() which is fully dynamic.
    
    def __init__(self):
        """
        Initialize the fallback router agent.
        
        NOTE: Removed entity parameter with default "note".
        Entity is now always passed to generate() or generate_for_entity().
        """
        pass

    def generate(self, entity: str, model_name: str) -> str:
        """
        Generate router code for the specified entity.
        
        Args:
            entity: Entity name (e.g., "product", "task", "user")
            model_name: Model class name (e.g., "Product", "Task", "User")
        
        Returns:
            Complete router code as a string
            
        Raises:
            ValueError: If entity or model_name not provided
        
        BREAKING CHANGE: Entity and model_name are now REQUIRED.
        No more hardcoded defaults like "Note" or "Item".
        """
        if not entity or not model_name:
            raise ValueError(
                "FallbackRouterAgent.generate() requires entity and model_name! "
                "Use entity_discovery.discover_primary_entity() to get them. "
                "No hardcoded defaults are allowed."
            )
        return self.generate_for_entity(entity, model_name)

    def generate_for_entity(self, entity: str, model_name: str) -> str:
        """
        Generate a CRUD router for a specific entity.
        
        Args:
            entity: Base entity name (e.g., "product", "task")
            model_name: Model class name (e.g., "Product", "Task")
            
        Returns:
            Complete FastAPI router code with all CRUD operations
        """
        if not entity or not model_name:
            raise ValueError("entity and model_name are required!")
        
        entity_lower = entity.lower()
        entity_plural = get_entity_plural(entity_lower)
        
        return f'''# backend/app/routers/{entity_plural}.py
"""
{model_name} CRUD Router - Fallback Template
Generated by FallbackRouterAgent when LLM failed.
"""
from fastapi import APIRouter, HTTPException, Query
from typing import List
from beanie import PydanticObjectId

from app.models import {model_name}

# NOTE: No prefix here - main.py adds prefix when including router
router = APIRouter()


@router.post("", response_model={model_name}, status_code=201)
async def create({entity_lower}: {model_name}):
    """Create a new {entity_lower}."""
    await {entity_lower}.create()
    return {entity_lower}


@router.get("", response_model=List[{model_name}])
async def get_all(
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
):
    """Get all {entity_plural} with pagination."""
    return await {model_name}.find_all().skip(skip).limit(limit).to_list()


@router.get("/{{{entity_lower}_id}}", response_model={model_name})
async def get_one({entity_lower}_id: PydanticObjectId):
    """Get a single {entity_lower} by ID."""
    {entity_lower} = await {model_name}.get({entity_lower}_id)
    if not {entity_lower}:
        raise HTTPException(status_code=404, detail="{model_name} not found")
    return {entity_lower}


@router.put("/{{{entity_lower}_id}}", response_model={model_name})
async def update({entity_lower}_id: PydanticObjectId, data: dict):
    """Update an existing {entity_lower}."""
    {entity_lower} = await {model_name}.get({entity_lower}_id)
    if not {entity_lower}:
        raise HTTPException(status_code=404, detail="{model_name} not found")
    await {entity_lower}.set(data)
    return {entity_lower}


@router.delete("/{{{entity_lower}_id}}")
async def delete({entity_lower}_id: PydanticObjectId):
    """Delete a {entity_lower}."""
    {entity_lower} = await {model_name}.get({entity_lower}_id)
    if not {entity_lower}:
        raise HTTPException(status_code=404, detail="{model_name} not found")
    await {entity_lower}.delete()
    return {{"status": "deleted", "id": str({entity_lower}_id)}}
'''.strip()
